<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: zh | Coding Honor]]></title>
  <link href="http://blog.codinghonor.com/categories/zh/atom.xml" rel="self"/>
  <link href="http://blog.codinghonor.com/"/>
  <updated>2014-07-09T05:05:36+08:00</updated>
  <id>http://blog.codinghonor.com/</id>
  <author>
    <name><![CDATA[武藏]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[散列的探测次数]]></title>
    <link href="http://blog.codinghonor.com/2014/07/09/detection-number-of-hashing/"/>
    <updated>2014-07-09T00:31:20+08:00</updated>
    <id>http://blog.codinghonor.com/2014/07/09/detection-number-of-hashing</id>
    <content type="html"><![CDATA[<p>散列是一种用于以常数平均时间执行插入、删除和查找的技术，想必大家对此都非常的熟悉。但如果问每次插入、删除亦或是查找平均都需要几次探测时，不见得就有那么多人能迅速答出来了。本着Flaunt的目的，本文将会带领大家一探究竟。（这么简单的一句竟然两次目的得逞！星宿老仙，法力无边！）</p>

<p>理想的散列表数据结构只不过是一个包含有关键字的具有固定大小的数组，并将关键字从0映射到TableSize-1的数组空间中去。但有人的地方就有江湖，有数据的地方就会有冲突（我叫王家卫）。特别是当关键字数量无限数组空间大小已定时，冲突几乎是无法避免的。这时自然就需要一个专门处理冲突的大侠来主持公道了。</p>

<p>总的来看，这位大侠处理冲突一般有两种思路：</p>

<p>1.分离链接法：将所有散列到同一个值的元素保留到一个链表中，理论上可以插入任意多的元素。</p>

<p>2.开放定址法：冲突发生时，尝试选择另外的单元，直到找到为止。（大侠和的一手好稀泥！）</p>

<p><img src="/images/emoticon/ffwe.jpg"></p>

<p>直观上来看，两种散列在实现效率上必定有所差异。如何来量化这种差异，便要引入平均探测次数的概念了。这里我们以开放定址法为例进行讨论。在冲突函数的选择上，由于线性探测、平方探测或者双散列都不是本文的讨论重点，所以采用随机冲突解法（理论上最优）。另外数组中数据的多少明显也会影响到插入或者查找时所需探测的次数，所以还得引入装填因子λ的概念。我们定义散列表的装填因子λ为散列表中的元素个数与散列表大小的比值。</p>

<p>有了这些铺垫后便可以探讨随机冲突解决方式的平均探测次数了。假设有一个很大的表，并且每次探测都与前面的探测无关（其实就是想表达随机探测的意思），首先让我们来看看一次不成功查找的期望探测次数。由于空单元所占的份额为1-λ，因此我们预计要探测的单元数是1/(1-λ)。<strong>一次成功查找的探测次数等于该特定元素插入时所需要的探测次数。当一个元素被插入时，可以看成是一次不成功查找的结果。因此，我们可以使用一次不成功查找的开销来计算一次成功查找的平均开销。</strong></p>

<p>由于λ在0到当前值之间变化，早期的插入操作开销肯定较小，所以平均开销会相应有所降低，不是简单的1/(1-λ)。我们可以通过使用积分计算插入时间平均值的方法来估计平均值，最终可得：</p>

<p>$$ I(\lambda) = \frac{1}{\lambda} \int_0^\lambda \frac{1}{1-x} \mathrm{d}x = \frac{1}{\lambda} ln \frac{1}{1-\lambda} $$</p>


<p>明显小于前面的预计探测次数1/(1-λ)。根据公式，我们绘制曲线图比较了线性探测与随机冲突解决方法的性能优劣，如下图所示：</p>

<p><img src="/images/2014/detection_number_of_hashing.jpg"></p>

<p><strong>S为成功查找；U为不成功查找；而I为插入</strong></p>

<p><em>使用线性探测方法插入与不成功查找的期望探测次数为0.5*(1+1/(1-λ)<sup>2</sup>)，对于成功查找为0.5(1+1/(1-λ))，这里不做推导。</em></p>

<p>可以看出随机方法的成功查找平均探测次数显然优于线性探测方法（理论最优嘛！）。例如λ=0.5时，随机方法的成功查找平均需要1.39次探测，线性探测方法成功查找需要1.5次探测（插入需要2.5次探测）。如果λ大于0.75，线性探测所需的探测次数上升明显，已经非常不适合继续使用。这种情况下只能再散列或者使用可扩散列的办法解决散列表过满的问题。</p>

<p>打完收工！</p>

<p><em>所有内容均参考自《数据结构与算法分析 &ndash; C语言描述》</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[暴君]]></title>
    <link href="http://blog.codinghonor.com/2014/07/04/tyrant/"/>
    <updated>2014-07-04T01:46:53+08:00</updated>
    <id>http://blog.codinghonor.com/2014/07/04/tyrant</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/tyrant.jpg"></p>

<blockquote><p><em>《暴君》的创意是我见过的电视剧中最棒的一部,这部剧让我兴奋。 &mdash; 李安</em></p></blockquote>

<p>最近在看<a href="http://movie.douban.com/subject/22232279/" target="_blank">《暴君》</a>这部美剧，由《国土安全》制作人 Howard Gordon、Gideon Raff 及《迷失》制作人 Craig Wright 共同制作，讲述一个普通美国家庭被卷入中东国家暴乱的故事。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二分查找]]></title>
    <link href="http://blog.codinghonor.com/2014/06/24/binary-search/"/>
    <updated>2014-06-24T21:39:09+08:00</updated>
    <id>http://blog.codinghonor.com/2014/06/24/binary-search</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/knuth.jpg"></p>

<p><strong>Donald Knuth</strong> &mdash; <em>a computer scientist</em></p>

<h2>逸闻趣事</h2>

<p>计算机领域内人才济济，各路神仙竞相释放大招。创世神们的事迹就不一一列举了，单是那一个个优美的小算法，在我眼中也是一件件上古奇兵。</p>

<p>对没错，前面这段是欲扬先抑。虽然领域内的能人堪比北京的处级干部般多如牛毛，但依旧阻挡不住下面这件令我震惊的事的发生：</p>

<blockquote><p><em>Donald Knuth在叙述查找算法的历史时指出，尽管第一篇有关二分查找（折半查找）算法的文章在1946年就发布了，可16年后才有人发表了（这是一个很好的限定）能正确查找各种规模的列表算法。</em></p></blockquote>

<p>诸位感受下，这16年来的计算机界（至少是学术界），竟然连个简单的折半查找都没正确的实现出来。这至少说明有相当一部分的从业人员算法基本功是不过关的。当然，你可以说这不重要。但我觉得算法便如武侠世界中的内功，练得好绝对对以后修炼各派神功大有裨益。</p>

<p>说起老爷子，还有一段逸闻趣事值分享。当年老爷子觉得现有的排版系统不好开始制造Tex时，第一版的源码老爷子是写在一个很厚的笔记本上的！请注意，这里是一个真正意义上的纸质笔记本。</p>

<blockquote><p><em>When I wrote TeX originally in 1977 and ’78, of course I didn’t have literate programming but I did have structured programming. I wrote it in a big notebook in longhand, in pencil.</em></p>

<p><em>Six months later, after I had gone through the whole project, I started typing into the computer. And did the debugging in March of ’78 while I had started writing the program in October of ’77. The code for that is in the Stanford archives—it’s all in pencil—and of course I would come back and change a subroutine as I learned what it should be.</em></p></blockquote>

<p>看到这里时我已热泪盈眶，这六个月高老爷子到底是如何组织自己的代码的，这才应该是真正意义上的最强大脑。当然也可以理解这是一种偏执，见仁见智罢了。有时候不去过分的迷信权威其实对于破立是非常有好处的（推荐阅读王垠的<a href="http://www.yinwang.org/blog-cn/2014/01/04/authority/" target="_blank">《我和权威的故事》</a>）。</p>

<h2>那些坑</h2>

<p>回到正题，接着说二分查找。究竟这里的二分查找难在什么地方，竟引得无数英雄折腰于此！我觉得这个问题至少存在以下3个坑（对那些基本功扎实的程序员来说：空中飘来五个字，这都不是事儿！）：</p>

<p><strong>1.中值的计算方式</strong></p>

<p>这里最容易忽略的就是溢出问题。如果我们理所应当的认为，中值应该这样计算：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">high</span> <span class="o">+</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>那么就肯定会被这种方式甩出一条街：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>当然，如果你用这种方式，那明显会更好一些：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="n">low</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这里核心的问题就是在避免两数相加以后 int 溢出的问题，后面的两种方式就很好的避免了这种情况的发生。第三种方式因为采用了位运算，在速度上更优。当然，别习惯性的在这里 >>2 就可以了。</p>

<p><strong>2.选择区间是否对称</strong></p>

<p>这又是一个让很多人栽倒的地方，边界问题考虑稍微有点疏忽，很容易就会掉进坑里。假如我们这里选择定义一个闭区间的话，那应该这样写：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>相应的循环体应该是这样的：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// TODO</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>当然，这里你也可以写成一个半开半闭的区间：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>但对应的循环体就应该是这样的：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// TODO</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>好多人在这里定义的时候想当然，没有仔细考虑边界，在循环条件是 &lt;= 还是 &lt; 的时候掉进了坑里。另外，如果这里采用指针的话，还存在另外一个问题，第一种闭区间的写法在计算 n-1 的时候容易指向一个无效地址：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">low</span><span class="p">,</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">high</span><span class="p">;</span>
</span><span class='line'><span class="n">low</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'><span class="n">high</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>如果这个时候 n 是 0 的话，那又会妥妥的掉坑里。不过，这种情况对于半开半闭区间不存在问题。</p>

<p><strong>3.重复元素的处理</strong></p>

<p>大部分人在这里理所当然的认为找到就应该直接跳出循环体，根本没有考虑到重复元素这种情况。如果要返回的是第一个元素的话，那么简单的跳出肯定有问题。</p>

<p>最终的实现如下：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Binary Search </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'><span class="k">while</span> <span class="o">(</span><span class="n">low</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="o">((</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="o">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">a</span><span class="o">[</span><span class="n">mid</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">return</span> <span class="n">high</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">a</span><span class="o">[</span><span class="n">high</span><span class="o">]</span> <span class="o">==</span> <span class="n">v</span> <span class="o">?</span> <span class="n">high</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>小结</h2>

<p>学习各种新的技术无疑对开阔眼界大有帮助，也可以让自己的工具盒里有着各式各样顺手的工具。但基础依旧是基础，经典依旧是经典。数据结构、算法、编译器、程序语言设计、操作系统等，对这些内容掌握的熟练程度，某种意义上决定了你在整个梯队中的位置。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如来之由来]]></title>
    <link href="http://blog.codinghonor.com/2014/06/20/name-of-buddha/"/>
    <updated>2014-06-20T23:11:31+08:00</updated>
    <id>http://blog.codinghonor.com/2014/06/20/name-of-buddha</id>
    <content type="html"><![CDATA[<p>“阿耨楼陀，实相并不是文字言语或意念知识所能表达得到的。只有禅定所生的智慧，才可以使我们确认到实相的真绪。阿耨楼陀,你是没法用言语来表达芒果的真正味道，并让他知道是怎样的。我们只有从亲身的体验，才可以掌握到真相。这也是我时常劝比丘们不要在理论上浪费宝贵的时间，而应多实习彻观一切的原因。</p>

<p>“一切法的性体，都是‘如是’的，这是万法之妙性。莲花从‘如是’而生起，阿耨楼陀从‘如是’而起，乔达摩也从‘如是’而生。我们可以称所有从‘如是’生起者为‘如来’，一切法从‘如是’生起，又将回归何处？一切法都回归到‘如是’。归到‘如是’，也可称为‘如去’。其实，一切法都没从哪儿来或到哪儿去，因为它们的本性‘如是’。阿耨楼陀，‘如是’的更正确意思，应该是‘无从来者’和‘无所去者’。阿耨楼陀，从现在开始，我将叫自己‘如来’。我喜欢这名词，因为它可以避免因分别而生起的字眼儿，像‘我’或‘我的’。”</p>

<p>阿耨楼陀微笑说道：“我们都知道我们全都从‘如是’而生起，但我们会只让你专用‘如来’这个名号。每次当我们如此称呼你的时候，便会提醒我们所有众生都具有这无始无终的‘如来’本性。”</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高质量设计的十一个特征]]></title>
    <link href="http://blog.codinghonor.com/2014/06/19/11-characteristics-of-high-quality-design/"/>
    <updated>2014-06-19T18:24:13+08:00</updated>
    <id>http://blog.codinghonor.com/2014/06/19/11-characteristics-of-high-quality-design</id>
    <content type="html"><![CDATA[<p>如果你是一个愿意雕琢自己代码的开发者，那么你肯定会在每次开发结束以后对其进行一定的总结。因为你知道，从中得出的经验教训将会对下次的开发工作有着非常好的指导意义。当然我也不例外，并时常自满于这四五年来的经验积累。但当这些非常自我的开发经验遇到《代码大全》作者总结的高质量设计特征时，在短暂的於我心有戚戚焉之后，我陷入了一种无奈——到底还有多少知识的宝藏藏匿于整个知识的疆界中，而我却茫然不知。</p>

<p>从自我批评的角度来看，类似的问题都可以简单的归结于读书不多不广。但客观上来讲，我们其实也可以为自己找一些借口。步入现代社会以后，人类知识积累的速度越来越快。随着知识的疆界变得越来越大，如果我们在知识获取方式上没有一次革新的话，总有一天我们会惊诧于目前获取及使用知识的效率是如此之低效。也许脑机接口将是一个解决该问题的突破口，不过在类似技术还没有成熟起来之前，一些朴素的刻苦读书的道理貌似是目前唯一的解决方案。</p>

<p>看来我也能写这种翻译腔十足、内容空洞无物以及面向程序员的小品文了（<a href="http://blog.jobbole.com/all-posts/" target="_blank">重灾区在这里</a>）。回到正题，实际上下面的关于高质量设计的11个特征应该是本文的重点（内容来自《代码大全》）：</p>

<ol>
<li><p><strong>最小的复杂度</strong>（Minimal complexity） 设计的首要目标就是要让复杂度最小。要避免做出“聪明的”设计，因为“聪明的”设计常常都是难以理解的。应该做出简单且易于理解的设计。如果你的设计方案不能让你在专注于程序的一部分时安心的忽视其他部分的话，这一设计就没有什么作用了。</p></li>
<li><p><strong>易于维护</strong>（Ease of maintenance） 易于维护意味着在设计时为做维护工作的程序员着想。请时刻想着这些维护程序员可能会就你写的代码而提出的问题。把这些程序员当成你的听众，进而设计出能自明的（self-explanatory）系统来。</p></li>
<li><p><strong>松散耦合</strong>（Loose coupling） 松散耦合意味着在设计时让程序的各个组成部分之间关联最小。通过应用类接口中的合理抽象、封装性及信息隐藏等原则，设计出相互关联尽可能最小的类。减少关联也就减少了集成、测试与维护的工作量。</p></li>
<li><p><strong>可扩展性</strong>（Extensibility） 可扩展性是说你能增强系统的功能而无须破坏其底层结构。你可以改动系统的某一部分而不会影响到其他部分。越是可能发生的改动，越不会给系统造成什么破坏。</p></li>
<li><p><strong>可重用性</strong>（Reusability） 可重用性意味着所设计的系统的组成部分能在其他系统中重复使用。</p></li>
<li><p><strong>高扇入</strong>（High fan-in） 高扇入就是说让大量的累使用某个给定的类。这意味着设计出的系统很好的利用了在较低层次上的工具类（utility classes）。</p></li>
<li><p><strong>低扇出</strong>（Low fan-out） 低扇出就是说让一个类里少量或适中的使用其他的类。高扇出（超过约7个）说明一个类使用了大量其他的类，因此可能变得过于复杂。研究发现，无论考虑某个子程序调用其他子程序的里量，还是考虑某个类使用其他类的量，低扇出的原则都是有益的（Card and Glass 1990; Basili, Briand, and Melo 1996）。</p></li>
<li><p><strong>可移植性</strong>（Portability） 可移植性是说应该这样设计系统，使它能很方便的移植到其他环境中。</p></li>
<li><p><strong>精简型</strong>（Leanness） 精简型意味着设计出的系统没有多余的部分（Wirth 1995, McConnnell 1997）。伏尔泰曾说，一本书的完成，不在它不能加入任何内容的时候，而在不能再删去任何内容的时候。在软件领域中，这一观点就更正确，因为任何多余的代码也需要开发、复审和测试，并且当修改了其他代码之后还需要重新考虑它们。软件的后续版本也要和这些多余代码保持向后兼容。要问这个关键的问题：“这虽然简单，但把它加进来之后会损害什么呢？”</p></li>
<li><p><strong>层次性</strong>（Stratification） 层次性意味着尽量保持系统各个分解层的层次性，使你能在任意的层面上观察系统，并得到某种具有一致性的看法。设计出来的系统应该能在任意层次上观察而不需要进入其他层次。</p></li>
<li><p><strong>标准技术</strong>（Standard techniques） 一个系统所依赖的外来的、古怪的东西越多，别人在第一次想要理解它的时候就越是头疼。要尽量用标准化的、常用的方法，让整个系统给人一种熟悉的感觉。</p></li>
</ol>


<p>放弃那些无聊又浪费时间的小品文吧，多读领域内的经典书籍，无论是技能还是逼格都会得到极大的提升。</p>

<p>最后列上自己最近在读的两本书。与君共勉！</p>

<p><a href="http://book.douban.com/subject/1477390/" target="_blank"><em>《代码大全》</em></a></p>

<p><a href="http://book.douban.com/subject/1139426/" target="_blank"><em>《数据结构与算法分析 &ndash; C语言描述》</em></a></p>
]]></content>
  </entry>
  
</feed>
